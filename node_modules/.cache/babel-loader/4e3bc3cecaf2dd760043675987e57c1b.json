{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\n\nconst {\n  helper,\n  assert,\n  debugError\n} = require('./helper');\n\nconst {\n  Events\n} = require('./Events');\n\nclass NetworkManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n    /** @type {!Map<string, !Request>} */\n\n    this._requestIdToRequest = new Map();\n    /** @type {!Map<string, !Protocol.Network.requestWillBeSentPayload>} */\n\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    /** @type {!Object<string, string>} */\n\n    this._extraHTTPHeaders = {};\n    this._offline = false;\n    /** @type {?{username: string, password: string}} */\n\n    this._credentials = null;\n    /** @type {!Set<string>} */\n\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    /** @type {!Map<string, string>} */\n\n    this._requestIdToInterceptionId = new Map();\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  async initialize() {\n    await this._client.send('Network.enable');\n    if (this._ignoreHTTPSErrors) await this._client.send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    });\n  }\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n\n\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n  /**\n   * @param {!Object<string, string>} extraHTTPHeaders\n   */\n\n\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n\n    await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: this._extraHTTPHeaders\n    });\n  }\n  /**\n   * @return {!Object<string, string>}\n   */\n\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n  /**\n   * @param {boolean} value\n   */\n\n\n  async setOfflineMode(value) {\n    if (this._offline === value) return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n  /**\n   * @param {string} userAgent\n   */\n\n\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', {\n      userAgent\n    });\n  }\n  /**\n   * @param {boolean} enabled\n   */\n\n\n  async setCacheEnabled(enabled) {\n    this._userCacheDisabled = !enabled;\n    await this._updateProtocolCacheDisabled();\n  }\n  /**\n   * @param {boolean} value\n   */\n\n\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n\n    if (enabled) {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.disable')]);\n    }\n  }\n\n  async _updateProtocolCacheDisabled() {\n    await this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled\n    });\n  }\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   */\n\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const interceptionId = this._requestIdToInterceptionId.get(requestId);\n\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToInterceptionId.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n  /**\n   * @param {!Protocol.Fetch.authRequiredPayload} event\n   */\n\n\n  _onAuthRequired(event) {\n    /** @type {\"Default\"|\"CancelAuth\"|\"ProvideCredentials\"} */\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(debugError);\n  }\n  /**\n   * @param {!Protocol.Fetch.requestPausedPayload} event\n   */\n\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToInterceptionId.set(requestId, interceptionId);\n    }\n  }\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {?string} interceptionId\n   */\n\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(Events.NetworkManager.Request, request);\n  }\n  /**\n   * @param {!Protocol.Network.requestServedFromCachePayload} event\n   */\n\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n  }\n  /**\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new Response(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._bodyLoadedPromiseFulfill.call(null, new Error('Response body is unavailable for redirect responses'));\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.Response, response);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n  /**\n   * @param {!Protocol.Network.responseReceivedPayload} event\n   */\n\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new Response(this._client, request, event.response);\n    request._response = response;\n    this.emit(Events.NetworkManager.Response, response);\n  }\n  /**\n   * @param {!Protocol.Network.loadingFinishedPayload} event\n   */\n\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._bodyLoadedPromiseFulfill.call(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n  /**\n   * @param {!Protocol.Network.loadingFailedPayload} event\n   */\n\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._bodyLoadedPromiseFulfill.call(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.RequestFailed, request);\n  }\n\n}\n\nclass Request {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?Puppeteer.Frame} frame\n   * @param {string} interceptionId\n   * @param {boolean} allowInterception\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {!Array<!Request>} redirectChain\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._interceptionHandled = false;\n    this._response = null;\n    this._failureText = null;\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._headers = {};\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n\n    for (const key of Object.keys(event.request.headers)) this._headers[key.toLowerCase()] = event.request.headers[key];\n\n    this._fromMemoryCache = false;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  resourceType() {\n    return this._resourceType;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  method() {\n    return this._method;\n  }\n  /**\n   * @return {string|undefined}\n   */\n\n\n  postData() {\n    return this._postData;\n  }\n  /**\n   * @return {!Object}\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @return {?Response}\n   */\n\n\n  response() {\n    return this._response;\n  }\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n\n\n  frame() {\n    return this._frame;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n  /**\n   * @return {!Array<!Request>}\n   */\n\n\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  /**\n   * @return {?{errorText: string}}\n   */\n\n\n  failure() {\n    if (!this._failureText) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides\n   */\n\n\n  async continue(overrides = {}) {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this._interceptionHandled = true;\n    await this._client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response\n   */\n\n\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:')) return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    const responseBody = response.body && helper.isString(response.body) ? Buffer.from(\n    /** @type {string} */\n    response.body) :\n    /** @type {?Buffer} */\n    response.body || null;\n    /** @type {!Object<string, string>} */\n\n    const responseHeaders = {};\n\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n\n    if (response.contentType) responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders)) responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    await this._client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: response.status || 200,\n      responsePhrase: STATUS_TEXTS[response.status || 200],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {string=} errorCode\n   */\n\n\n  async abort(errorCode = 'failed') {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n}\n\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed'\n};\n\nclass Response {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  constructor(client, request, responsePayload) {\n    this._client = client;\n    this._request = request;\n    this._contentPromise = null;\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    };\n    this._status = responsePayload.status;\n    this._statusText = responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this._headers = {};\n\n    for (const key of Object.keys(responsePayload.headers)) this._headers[key.toLowerCase()] = responsePayload.headers[key];\n\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;\n  }\n  /**\n   * @return {{ip: string, port: number}}\n   */\n\n\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  ok() {\n    return this._status === 0 || this._status >= 200 && this._status <= 299;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  status() {\n    return this._status;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  statusText() {\n    return this._statusText;\n  }\n  /**\n   * @return {!Object}\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @return {?SecurityDetails}\n   */\n\n\n  securityDetails() {\n    return this._securityDetails;\n  }\n  /**\n   * @return {!Promise<!Buffer>}\n   */\n\n\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error) throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n\n    return this._contentPromise;\n  }\n  /**\n   * @return {!Promise<string>}\n   */\n\n\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n  /**\n   * @return {!Promise<!Object>}\n   */\n\n\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  /**\n   * @return {!Request}\n   */\n\n\n  request() {\n    return this._request;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n\n\n  frame() {\n    return this._request.frame();\n  }\n\n}\n\nclass SecurityDetails {\n  /**\n   * @param {!Protocol.Network.SecurityDetails} securityPayload\n   */\n  constructor(securityPayload) {\n    this._subjectName = securityPayload['subjectName'];\n    this._issuer = securityPayload['issuer'];\n    this._validFrom = securityPayload['validFrom'];\n    this._validTo = securityPayload['validTo'];\n    this._protocol = securityPayload['protocol'];\n  }\n  /**\n   * @return {string}\n   */\n\n\n  subjectName() {\n    return this._subjectName;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  issuer() {\n    return this._issuer;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  validFrom() {\n    return this._validFrom;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  validTo() {\n    return this._validTo;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  protocol() {\n    return this._protocol;\n  }\n\n}\n/**\n * @param {Object<string, string>} headers\n * @return {!Array<{name: string, value: string}>}\n */\n\n\nfunction headersArray(headers) {\n  const result = [];\n\n  for (const name in headers) {\n    if (!Object.is(headers[name], undefined)) result.push({\n      name,\n      value: headers[name] + ''\n    });\n  }\n\n  return result;\n} // List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.\n\n\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};\nmodule.exports = {\n  Request,\n  Response,\n  NetworkManager,\n  SecurityDetails\n};","map":{"version":3,"sources":["/Users/marshoward/Development/code/river/frontend/app/node_modules/puppeteer/lib/NetworkManager.js"],"names":["EventEmitter","require","helper","assert","debugError","Events","NetworkManager","constructor","client","ignoreHTTPSErrors","frameManager","_client","_ignoreHTTPSErrors","_frameManager","_requestIdToRequest","Map","_requestIdToRequestWillBeSentEvent","_extraHTTPHeaders","_offline","_credentials","_attemptedAuthentications","Set","_userRequestInterceptionEnabled","_protocolRequestInterceptionEnabled","_userCacheDisabled","_requestIdToInterceptionId","on","_onRequestPaused","bind","_onAuthRequired","_onRequestWillBeSent","_onRequestServedFromCache","_onResponseReceived","_onLoadingFinished","_onLoadingFailed","initialize","send","ignore","authenticate","credentials","_updateProtocolRequestInterception","setExtraHTTPHeaders","extraHTTPHeaders","key","Object","keys","value","isString","toLowerCase","headers","assign","setOfflineMode","offline","latency","downloadThroughput","uploadThroughput","setUserAgent","userAgent","setCacheEnabled","enabled","_updateProtocolCacheDisabled","setRequestInterception","Promise","all","handleAuthRequests","patterns","urlPattern","cacheDisabled","event","request","url","startsWith","requestId","interceptionId","get","_onRequest","delete","set","response","has","add","username","password","undefined","authChallengeResponse","catch","networkId","requestWillBeSentEvent","redirectChain","redirectResponse","_handleRequestRedirect","_redirectChain","frame","frameId","Request","emit","_fromMemoryCache","responsePayload","Response","_response","push","_bodyLoadedPromiseFulfill","call","Error","_requestId","_interceptionId","RequestFinished","_failureText","errorText","RequestFailed","allowInterception","_isNavigationRequest","loaderId","type","_allowInterception","_interceptionHandled","_url","_resourceType","_method","method","_postData","postData","_headers","_frame","resourceType","isNavigationRequest","slice","failure","continue","overrides","headersArray","error","respond","responseBody","body","Buffer","from","responseHeaders","header","contentType","String","byteLength","responseCode","status","responsePhrase","STATUS_TEXTS","toString","abort","errorCode","errorReason","errorReasons","_request","_contentPromise","_bodyLoadedPromise","fulfill","_remoteAddress","ip","remoteIPAddress","port","remotePort","_status","_statusText","statusText","_fromDiskCache","fromDiskCache","_fromServiceWorker","fromServiceWorker","_securityDetails","securityDetails","SecurityDetails","remoteAddress","ok","buffer","then","base64Encoded","text","content","json","JSON","parse","fromCache","securityPayload","_subjectName","_issuer","_validFrom","_validTo","_protocol","subjectName","issuer","validFrom","validTo","protocol","result","name","is","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\nconst {helper, assert, debugError} = require('./helper');\nconst {Events} = require('./Events');\n\nclass NetworkManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n    /** @type {!Map<string, !Request>} */\n    this._requestIdToRequest = new Map();\n    /** @type {!Map<string, !Protocol.Network.requestWillBeSentPayload>} */\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    /** @type {!Object<string, string>} */\n    this._extraHTTPHeaders = {};\n\n    this._offline = false;\n\n    /** @type {?{username: string, password: string}} */\n    this._credentials = null;\n    /** @type {!Set<string>} */\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    /** @type {!Map<string, string>} */\n    this._requestIdToInterceptionId = new Map();\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  async initialize() {\n    await this._client.send('Network.enable');\n    if (this._ignoreHTTPSErrors)\n      await this._client.send('Security.setIgnoreCertificateErrors', {ignore: true});\n  }\n\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  /**\n   * @param {!Object<string, string>} extraHTTPHeaders\n   */\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    await this._client.send('Network.setExtraHTTPHeaders', { headers: this._extraHTTPHeaders });\n  }\n\n  /**\n   * @return {!Object<string, string>}\n   */\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setOfflineMode(value) {\n    if (this._offline === value)\n      return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n\n  /**\n   * @param {string} userAgent\n   */\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', { userAgent });\n  }\n\n  /**\n   * @param {boolean} enabled\n   */\n  async setCacheEnabled(enabled) {\n    this._userCacheDisabled = !enabled;\n    await this._updateProtocolCacheDisabled();\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled)\n      return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    if (enabled) {\n      await Promise.all([\n        this._updateProtocolCacheDisabled(),\n        this._client.send('Fetch.enable', {\n          handleAuthRequests: true,\n          patterns: [{urlPattern: '*'}],\n        }),\n      ]);\n    } else {\n      await Promise.all([\n        this._updateProtocolCacheDisabled(),\n        this._client.send('Fetch.disable')\n      ]);\n    }\n  }\n\n  async _updateProtocolCacheDisabled() {\n    await this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled\n    });\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   */\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n      const interceptionId = this._requestIdToInterceptionId.get(requestId);\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n        this._requestIdToInterceptionId.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n      return;\n    }\n    this._onRequest(event, null);\n  }\n\n  /**\n   * @param {!Protocol.Fetch.authRequiredPayload} event\n   */\n  _onAuthRequired(event) {\n    /** @type {\"Default\"|\"CancelAuth\"|\"ProvideCredentials\"} */\n    let response = 'Default';\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n      this._attemptedAuthentications.add(event.requestId);\n    }\n    const {username, password} = this._credentials || {username: undefined, password: undefined};\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: { response, username, password },\n    }).catch(debugError);\n  }\n\n  /**\n   * @param {!Protocol.Fetch.requestPausedPayload} event\n   */\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n    if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToInterceptionId.set(requestId, interceptionId);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {?string} interceptionId\n   */\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n    this._requestIdToRequest.set(event.requestId, request);\n    this.emit(Events.NetworkManager.Request, request);\n  }\n\n\n  /**\n   * @param {!Protocol.Network.requestServedFromCachePayload} event\n   */\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    if (request)\n      request._fromMemoryCache = true;\n  }\n\n  /**\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new Response(this._client, request, responsePayload);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._bodyLoadedPromiseFulfill.call(null, new Error('Response body is unavailable for redirect responses'));\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.Response, response);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.responseReceivedPayload} event\n   */\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request)\n      return;\n    const response = new Response(this._client, request, event.response);\n    request._response = response;\n    this.emit(Events.NetworkManager.Response, response);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFinishedPayload} event\n   */\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response())\n      request.response()._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFailedPayload} event\n   */\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response)\n      response._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.RequestFailed, request);\n  }\n}\n\nclass Request {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?Puppeteer.Frame} frame\n   * @param {string} interceptionId\n   * @param {boolean} allowInterception\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {!Array<!Request>} redirectChain\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._interceptionHandled = false;\n    this._response = null;\n    this._failureText = null;\n\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._headers = {};\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n    for (const key of Object.keys(event.request.headers))\n      this._headers[key.toLowerCase()] = event.request.headers[key];\n\n    this._fromMemoryCache = false;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {string}\n   */\n  resourceType() {\n    return this._resourceType;\n  }\n\n  /**\n   * @return {string}\n   */\n  method() {\n    return this._method;\n  }\n\n  /**\n   * @return {string|undefined}\n   */\n  postData() {\n    return this._postData;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?Response}\n   */\n  response() {\n    return this._response;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._frame;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n\n  /**\n   * @return {!Array<!Request>}\n   */\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n\n  /**\n   * @return {?{errorText: string}}\n   */\n  failure() {\n    if (!this._failureText)\n      return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n\n  /**\n   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides\n   */\n  async continue(overrides = {}) {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:'))\n      return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this._interceptionHandled = true;\n    await this._client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData,\n      headers: headers ? headersArray(headers) : undefined,\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response\n   */\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:'))\n      return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n\n    const responseBody = response.body && helper.isString(response.body) ? Buffer.from(/** @type {string} */(response.body)) : /** @type {?Buffer} */(response.body || null);\n\n    /** @type {!Object<string, string>} */\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers))\n        responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n    if (response.contentType)\n      responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders))\n      responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n\n    await this._client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: response.status || 200,\n      responsePhrase: STATUS_TEXTS[response.status || 200],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined,\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {string=} errorCode\n   */\n  async abort(errorCode = 'failed') {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:'))\n      return;\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n}\n\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed',\n};\n\nclass Response {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  constructor(client, request, responsePayload) {\n    this._client = client;\n    this._request = request;\n    this._contentPromise = null;\n\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort,\n    };\n    this._status = responsePayload.status;\n    this._statusText = responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this._headers = {};\n    for (const key of Object.keys(responsePayload.headers))\n      this._headers[key.toLowerCase()] = responsePayload.headers[key];\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;\n  }\n\n  /**\n   * @return {{ip: string, port: number}}\n   */\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  ok() {\n    return this._status === 0 || (this._status >= 200 && this._status <= 299);\n  }\n\n  /**\n   * @return {number}\n   */\n  status() {\n    return this._status;\n  }\n\n  /**\n   * @return {string}\n   */\n  statusText() {\n    return this._statusText;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?SecurityDetails}\n   */\n  securityDetails() {\n    return this._securityDetails;\n  }\n\n  /**\n   * @return {!Promise<!Buffer>}\n   */\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error)\n          throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n    return this._contentPromise;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n\n  /**\n   * @return {!Promise<!Object>}\n   */\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  /**\n   * @return {!Request}\n   */\n  request() {\n    return this._request;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._request.frame();\n  }\n}\n\nclass SecurityDetails {\n  /**\n   * @param {!Protocol.Network.SecurityDetails} securityPayload\n   */\n  constructor(securityPayload) {\n    this._subjectName = securityPayload['subjectName'];\n    this._issuer = securityPayload['issuer'];\n    this._validFrom = securityPayload['validFrom'];\n    this._validTo = securityPayload['validTo'];\n    this._protocol = securityPayload['protocol'];\n  }\n\n  /**\n   * @return {string}\n   */\n  subjectName() {\n    return this._subjectName;\n  }\n\n  /**\n   * @return {string}\n   */\n  issuer() {\n    return this._issuer;\n  }\n\n  /**\n   * @return {number}\n   */\n  validFrom() {\n    return this._validFrom;\n  }\n\n  /**\n   * @return {number}\n   */\n  validTo() {\n    return this._validTo;\n  }\n\n  /**\n   * @return {string}\n   */\n  protocol() {\n    return this._protocol;\n  }\n}\n\n/**\n * @param {Object<string, string>} headers\n * @return {!Array<{name: string, value: string}>}\n */\nfunction headersArray(headers) {\n  const result = [];\n  for (const name in headers) {\n    if (!Object.is(headers[name], undefined))\n      result.push({name, value: headers[name] + ''});\n  }\n  return result;\n}\n\n// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required',\n};\n\nmodule.exports = {Request, Response, NetworkManager, SecurityDetails};\n"]},"metadata":{},"sourceType":"script"}
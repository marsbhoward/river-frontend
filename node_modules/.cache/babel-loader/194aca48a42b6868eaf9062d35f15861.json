{"ast":null,"code":"var PriorityQueue = function (size) {\n  var me = {},\n      slots,\n      i,\n      total = null; // initialize arrays to hold queue elements\n\n  size = Math.max(+size | 0, 1);\n  slots = [];\n\n  for (i = 0; i < size; i += 1) {\n    slots.push([]);\n  } //  Public methods\n\n\n  me.size = function () {\n    var i;\n\n    if (total === null) {\n      total = 0;\n\n      for (i = 0; i < size; i += 1) {\n        total += slots[i].length;\n      }\n    }\n\n    return total;\n  };\n\n  me.enqueue = function (obj, priority) {\n    var priorityOrig; // Convert to integer with a default value of 0.\n\n    priority = priority && +priority | 0 || 0; // Clear cache for total.\n\n    total = null;\n\n    if (priority) {\n      priorityOrig = priority;\n\n      if (priority < 0 || priority >= size) {\n        priority = size - 1; // put obj at the end of the line\n\n        console.error(\"invalid priority: \" + priorityOrig + \" must be between 0 and \" + priority);\n      }\n    }\n\n    slots[priority].push(obj);\n  };\n\n  me.dequeue = function (callback) {\n    var obj = null,\n        i,\n        sl = slots.length; // Clear cache for total.\n\n    total = null;\n\n    for (i = 0; i < sl; i += 1) {\n      if (slots[i].length) {\n        obj = slots[i].shift();\n        break;\n      }\n    }\n\n    return obj;\n  };\n\n  return me;\n};\n\nfunction Bottleneck(maxConcurrent, rateLimit, priorityRange, defaultPriority, cluster) {\n  if (isNaN(maxConcurrent) || isNaN(rateLimit)) {\n    throw \"maxConcurrent and rateLimit must be numbers\";\n  }\n\n  priorityRange = priorityRange || 1;\n\n  if (isNaN(priorityRange)) {\n    throw \"priorityRange must be a number\";\n  }\n\n  priorityRange = parseInt(priorityRange);\n  defaultPriority = defaultPriority ? defaultPriority : Math.floor(priorityRange / 2);\n\n  if (isNaN(defaultPriority)) {\n    throw \"defaultPriority must be a number\";\n  }\n\n  defaultPriority = defaultPriority >= priorityRange ? priorityRange - 1 : defaultPriority;\n  defaultPriority = parseInt(defaultPriority);\n  this.cluster = cluster;\n  this.rateLimit = parseInt(rateLimit);\n  this.maxConcurrent = this.rateLimit ? 1 : parseInt(maxConcurrent);\n  this._waitingClients = new PriorityQueue(priorityRange);\n  this._priorityRange = priorityRange;\n  this._defaultPriority = defaultPriority;\n  this._nextRequest = Date.now();\n  this._tasksRunning = 0;\n}\n\nBottleneck.prototype.setName = function (name) {\n  this.name = name;\n};\n\nBottleneck.prototype.setRateLimit = function (rateLimit) {\n  if (isNaN(rateLimit)) {\n    throw \"rateLimit must be a number\";\n  }\n\n  this.rateLimit = parseInt(rateLimit);\n\n  if (this.rateLimit > 0) {\n    this.maxConcurrent = 1;\n  }\n};\n\nBottleneck.prototype.submit = function (options, clientCallback) {\n  var self = this;\n  var priority = null;\n\n  if (typeof options == \"number\") {\n    priority = parseInt(options);\n  } else {\n    priority = options.priority;\n  }\n\n  priority = Number.isInteger(priority) ? priority : self._defaultPriority;\n  priority = priority > self._priorityRange - 1 ? self._priorityRange - 1 : priority;\n\n  this._waitingClients.enqueue(clientCallback, priority);\n\n  self._tryToRun();\n\n  return;\n};\n\nBottleneck.prototype._tryToRun = function () {\n  var self = this;\n\n  if (self._tasksRunning < self.maxConcurrent && self.hasWaitingClients()) {\n    ++self._tasksRunning;\n    var wait = Math.max(self._nextRequest - Date.now(), 0);\n    self._nextRequest = Date.now() + wait + self.rateLimit;\n    var obj = self.dequeue();\n    var next = obj.next;\n    var limiter = obj.limiter;\n    setTimeout(function () {\n      var done = function () {\n        --self._tasksRunning;\n\n        self._tryToRun();\n      };\n\n      next(done, limiter);\n    }, wait);\n  }\n\n  return;\n};\n\nBottleneck.prototype.hasWaitingClients = function () {\n  if (this._waitingClients.size()) {\n    return true;\n  }\n\n  if (this.cluster && this.cluster._waitingClients()) {\n    return true;\n  }\n\n  return false;\n};\n\nBottleneck.prototype.dequeue = function () {\n  if (this._waitingClients.size()) {\n    return {\n      next: this._waitingClients.dequeue(),\n      limiter: null\n    };\n  }\n\n  return this.cluster.dequeue(this.name);\n};\n\nBottleneck.Cluster = Bottleneck.prototype.Cluster = require(\"./Cluster\");\nmodule.exports = Bottleneck;","map":{"version":3,"sources":["/Users/marshoward/Development/code/river/frontend/app/node_modules/bottleneckp/lib/Bottleneck.js"],"names":["PriorityQueue","size","me","slots","i","total","Math","max","push","length","enqueue","obj","priority","priorityOrig","console","error","dequeue","callback","sl","shift","Bottleneck","maxConcurrent","rateLimit","priorityRange","defaultPriority","cluster","isNaN","parseInt","floor","_waitingClients","_priorityRange","_defaultPriority","_nextRequest","Date","now","_tasksRunning","prototype","setName","name","setRateLimit","submit","options","clientCallback","self","Number","isInteger","_tryToRun","hasWaitingClients","wait","next","limiter","setTimeout","done","Cluster","require","module","exports"],"mappings":"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","sourcesContent":["var PriorityQueue = function(size) {\n    var me = {}, slots, i, total = null;\n\n    // initialize arrays to hold queue elements\n    size = Math.max(+size | 0, 1);\n    slots = [];\n    for (i = 0; i < size; i += 1) {\n        slots.push([]);\n    }\n\n    //  Public methods\n    me.size = function () {\n        var i;\n        if (total === null) {\n            total = 0;\n            for (i = 0; i < size; i += 1) {\n                total += slots[i].length;\n            }\n        }\n        return total;\n    };\n\n    me.enqueue = function (obj, priority) {\n        var priorityOrig;\n\n        // Convert to integer with a default value of 0.\n        priority = priority && + priority | 0 || 0;\n\n        // Clear cache for total.\n        total = null;\n        if (priority) {\n            priorityOrig = priority;\n            if (priority < 0 || priority >= size) {\n                priority = (size - 1);\n                // put obj at the end of the line\n                console.error(\"invalid priority: \" + priorityOrig + \" must be between 0 and \" + priority);\n            }\n        }\n\n        slots[priority].push(obj);\n    };\n\n    me.dequeue = function (callback) {\n        var obj = null, i, sl = slots.length;\n\n        // Clear cache for total.\n        total = null;\n        for (i = 0; i < sl; i += 1) {\n            if (slots[i].length) {\n                obj = slots[i].shift();\n                break;\n            }\n        }\n        return obj;\n    };\n\n    return me;\n};\n\nfunction Bottleneck(maxConcurrent, rateLimit, priorityRange, defaultPriority, cluster) {\n    if(isNaN(maxConcurrent) || isNaN(rateLimit)) {\n        throw \"maxConcurrent and rateLimit must be numbers\";\n    }\n\n    priorityRange = priorityRange || 1;\n    if(isNaN(priorityRange)) {\n        throw \"priorityRange must be a number\";\n    }\n    priorityRange = parseInt(priorityRange);\n    defaultPriority = defaultPriority ? defaultPriority : Math.floor(priorityRange/2);\n    if(isNaN(defaultPriority)) {\n        throw \"defaultPriority must be a number\";\n    }\n    defaultPriority = defaultPriority >= priorityRange ? priorityRange-1 : defaultPriority;\n    defaultPriority = parseInt(defaultPriority);\n\n    this.cluster = cluster;\n    this.rateLimit = parseInt(rateLimit);\n    this.maxConcurrent = this.rateLimit ? 1 : parseInt(maxConcurrent);\n    this._waitingClients = new PriorityQueue(priorityRange);\n    this._priorityRange = priorityRange;\n    this._defaultPriority = defaultPriority;\n    this._nextRequest = Date.now();\n    this._tasksRunning = 0;\n}\n\nBottleneck.prototype.setName = function(name) {\n    this.name = name;\n}\n\nBottleneck.prototype.setRateLimit = function(rateLimit) {\n    if(isNaN(rateLimit)) {\n\tthrow \"rateLimit must be a number\";\n    }\n    this.rateLimit = parseInt(rateLimit);\n    if(this.rateLimit > 0) {\n\tthis.maxConcurrent = 1;\n    }\n}\n\nBottleneck.prototype.submit = function(options, clientCallback) {\n    var self = this;\n    var priority = null;\n    if(typeof options == \"number\") {\n        priority = parseInt(options);\n    } else {\n        priority = options.priority;\n    }\n    priority = Number.isInteger(priority) ? priority: self._defaultPriority;\n    priority = priority > self._priorityRange-1 ? self._priorityRange-1 : priority;\n    this._waitingClients.enqueue(clientCallback, priority);\n    self._tryToRun();\n    return;\n}\n\nBottleneck.prototype._tryToRun = function() {\n    var self = this;\n    if(self._tasksRunning < self.maxConcurrent && self.hasWaitingClients()) {\n        ++self._tasksRunning;\n        var wait = Math.max(self._nextRequest - Date.now(), 0);\n        self._nextRequest = Date.now() + wait + self.rateLimit;\n        var obj = self.dequeue();\n\tvar next = obj.next;\n\tvar limiter = obj.limiter;\n        setTimeout(function(){\n            var done = function() {\n                --self._tasksRunning;\n                self._tryToRun();\n            }\n            next(done, limiter);\n        }, wait);\n    }\n    return;\n}\n\nBottleneck.prototype.hasWaitingClients = function() {\n    if(this._waitingClients.size()) {\n\treturn true;\n    }\n    if(this.cluster && this.cluster._waitingClients()) {\n\treturn true;\n    }\n    return false;\n}\n\nBottleneck.prototype.dequeue = function() {\n    if(this._waitingClients.size()) {\n\treturn {\n\t    next: this._waitingClients.dequeue(),\n\t    limiter: null\n\t};\n    }\n    return this.cluster.dequeue(this.name);\n}\n\nBottleneck.Cluster = Bottleneck.prototype.Cluster = require(\"./Cluster\");\n\nmodule.exports = Bottleneck;\n"]},"metadata":{},"sourceType":"script"}
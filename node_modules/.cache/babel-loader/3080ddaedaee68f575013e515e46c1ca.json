{"ast":null,"code":"/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {Object} SerializedAXNode\n * @property {string} role\n *\n * @property {string=} name\n * @property {string|number=} value\n * @property {string=} description\n *\n * @property {string=} keyshortcuts\n * @property {string=} roledescription\n * @property {string=} valuetext\n *\n * @property {boolean=} disabled\n * @property {boolean=} expanded\n * @property {boolean=} focused\n * @property {boolean=} modal\n * @property {boolean=} multiline\n * @property {boolean=} multiselectable\n * @property {boolean=} readonly\n * @property {boolean=} required\n * @property {boolean=} selected\n *\n * @property {boolean|\"mixed\"=} checked\n * @property {boolean|\"mixed\"=} pressed\n *\n * @property {number=} level\n * @property {number=} valuemin\n * @property {number=} valuemax\n *\n * @property {string=} autocomplete\n * @property {string=} haspopup\n * @property {string=} invalid\n * @property {string=} orientation\n *\n * @property {Array<SerializedAXNode>=} children\n */\nclass Accessibility {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n  }\n  /**\n   * @param {{interestingOnly?: boolean, root?: ?Puppeteer.ElementHandle}=} options\n   * @return {!Promise<!SerializedAXNode>}\n   */\n\n\n  async snapshot(options = {}) {\n    const {\n      interestingOnly = true,\n      root = null\n    } = options;\n    const {\n      nodes\n    } = await this._client.send('Accessibility.getFullAXTree');\n    let backendNodeId = null;\n\n    if (root) {\n      const {\n        node\n      } = await this._client.send('DOM.describeNode', {\n        objectId: root._remoteObject.objectId\n      });\n      backendNodeId = node.backendNodeId;\n    }\n\n    const defaultRoot = AXNode.createTree(nodes);\n    let needle = defaultRoot;\n\n    if (backendNodeId) {\n      needle = defaultRoot.find(node => node._payload.backendDOMNodeId === backendNodeId);\n      if (!needle) return null;\n    }\n\n    if (!interestingOnly) return serializeTree(needle)[0];\n    /** @type {!Set<!AXNode>} */\n\n    const interestingNodes = new Set();\n    collectInterestingNodes(interestingNodes, defaultRoot, false);\n    if (!interestingNodes.has(needle)) return null;\n    return serializeTree(needle, interestingNodes)[0];\n  }\n\n}\n/**\n * @param {!Set<!AXNode>} collection\n * @param {!AXNode} node\n * @param {boolean} insideControl\n */\n\n\nfunction collectInterestingNodes(collection, node, insideControl) {\n  if (node.isInteresting(insideControl)) collection.add(node);\n  if (node.isLeafNode()) return;\n  insideControl = insideControl || node.isControl();\n\n  for (const child of node._children) collectInterestingNodes(collection, child, insideControl);\n}\n/**\n * @param {!AXNode} node\n * @param {!Set<!AXNode>=} whitelistedNodes\n * @return {!Array<!SerializedAXNode>}\n */\n\n\nfunction serializeTree(node, whitelistedNodes) {\n  /** @type {!Array<!SerializedAXNode>} */\n  const children = [];\n\n  for (const child of node._children) children.push(...serializeTree(child, whitelistedNodes));\n\n  if (whitelistedNodes && !whitelistedNodes.has(node)) return children;\n  const serializedNode = node.serialize();\n  if (children.length) serializedNode.children = children;\n  return [serializedNode];\n}\n\nclass AXNode {\n  /**\n   * @param {!Protocol.Accessibility.AXNode} payload\n   */\n  constructor(payload) {\n    this._payload = payload;\n    /** @type {!Array<!AXNode>} */\n\n    this._children = [];\n    this._richlyEditable = false;\n    this._editable = false;\n    this._focusable = false;\n    this._expanded = false;\n    this._hidden = false;\n    this._name = this._payload.name ? this._payload.name.value : '';\n    this._role = this._payload.role ? this._payload.role.value : 'Unknown';\n    this._cachedHasFocusableChild;\n\n    for (const property of this._payload.properties || []) {\n      if (property.name === 'editable') {\n        this._richlyEditable = property.value.value === 'richtext';\n        this._editable = true;\n      }\n\n      if (property.name === 'focusable') this._focusable = property.value.value;\n      if (property.name === 'expanded') this._expanded = property.value.value;\n      if (property.name === 'hidden') this._hidden = property.value.value;\n    }\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  _isPlainTextField() {\n    if (this._richlyEditable) return false;\n    if (this._editable) return true;\n    return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  _isTextOnlyObject() {\n    const role = this._role;\n    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  _hasFocusableChild() {\n    if (this._cachedHasFocusableChild === undefined) {\n      this._cachedHasFocusableChild = false;\n\n      for (const child of this._children) {\n        if (child._focusable || child._hasFocusableChild()) {\n          this._cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n\n    return this._cachedHasFocusableChild;\n  }\n  /**\n   * @param {function(AXNode):boolean} predicate\n   * @return {?AXNode}\n   */\n\n\n  find(predicate) {\n    if (predicate(this)) return this;\n\n    for (const child of this._children) {\n      const result = child.find(predicate);\n      if (result) return result;\n    }\n\n    return null;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isLeafNode() {\n    if (!this._children.length) return true; // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n\n    if (this._isPlainTextField() || this._isTextOnlyObject()) return true; // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n\n    switch (this._role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n\n      default:\n        break;\n    } // Here and below: Android heuristics\n\n\n    if (this._hasFocusableChild()) return false;\n    if (this._focusable && this._name) return true;\n    if (this._role === 'heading' && this._name) return true;\n    return false;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isControl() {\n    switch (this._role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * @param {boolean} insideControl\n   * @return {boolean}\n   */\n\n\n  isInteresting(insideControl) {\n    const role = this._role;\n    if (role === 'Ignored' || this._hidden) return false;\n    if (this._focusable || this._richlyEditable) return true; // If it's not focusable but has a control role, then it's interesting.\n\n    if (this.isControl()) return true; // A non focusable child of a control is not interesting\n\n    if (insideControl) return false;\n    return this.isLeafNode() && !!this._name;\n  }\n  /**\n   * @return {!SerializedAXNode}\n   */\n\n\n  serialize() {\n    /** @type {!Map<string, number|string|boolean>} */\n    const properties = new Map();\n\n    for (const property of this._payload.properties || []) properties.set(property.name.toLowerCase(), property.value.value);\n\n    if (this._payload.name) properties.set('name', this._payload.name.value);\n    if (this._payload.value) properties.set('value', this._payload.value.value);\n    if (this._payload.description) properties.set('description', this._payload.description.value);\n    /** @type {SerializedAXNode} */\n\n    const node = {\n      role: this._role\n    };\n    /** @type {!Array<keyof SerializedAXNode>} */\n\n    const userStringProperties = ['name', 'value', 'description', 'keyshortcuts', 'roledescription', 'valuetext'];\n\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty)) continue;\n      node[userStringProperty] = properties.get(userStringProperty);\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n\n\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n\n    for (const booleanProperty of booleanProperties) {\n      // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,\n      // not whether focus is specifically on the root node.\n      if (booleanProperty === 'focused' && this._role === 'WebArea') continue;\n      const value = properties.get(booleanProperty);\n      if (!value) continue;\n      node[booleanProperty] = value;\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n\n\n    const tristateProperties = ['checked', 'pressed'];\n\n    for (const tristateProperty of tristateProperties) {\n      if (!properties.has(tristateProperty)) continue;\n      const value = properties.get(tristateProperty);\n      node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n\n\n    const numericalProperties = ['level', 'valuemax', 'valuemin'];\n\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty)) continue;\n      node[numericalProperty] = properties.get(numericalProperty);\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n\n\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];\n\n    for (const tokenProperty of tokenProperties) {\n      const value = properties.get(tokenProperty);\n      if (!value || value === 'false') continue;\n      node[tokenProperty] = value;\n    }\n\n    return node;\n  }\n  /**\n   * @param {!Array<!Protocol.Accessibility.AXNode>} payloads\n   * @return {!AXNode}\n   */\n\n\n  static createTree(payloads) {\n    /** @type {!Map<string, !AXNode>} */\n    const nodeById = new Map();\n\n    for (const payload of payloads) nodeById.set(payload.nodeId, new AXNode(payload));\n\n    for (const node of nodeById.values()) {\n      for (const childId of node._payload.childIds || []) node._children.push(nodeById.get(childId));\n    }\n\n    return nodeById.values().next().value;\n  }\n\n}\n\nmodule.exports = {\n  Accessibility\n};","map":{"version":3,"sources":["/Users/marshoward/Development/code/river/frontend/app/node_modules/puppeteer/lib/Accessibility.js"],"names":["Accessibility","constructor","client","_client","snapshot","options","interestingOnly","root","nodes","send","backendNodeId","node","objectId","_remoteObject","defaultRoot","AXNode","createTree","needle","find","_payload","backendDOMNodeId","serializeTree","interestingNodes","Set","collectInterestingNodes","has","collection","insideControl","isInteresting","add","isLeafNode","isControl","child","_children","whitelistedNodes","children","push","serializedNode","serialize","length","payload","_richlyEditable","_editable","_focusable","_expanded","_hidden","_name","name","value","_role","role","_cachedHasFocusableChild","property","properties","_isPlainTextField","_isTextOnlyObject","_hasFocusableChild","undefined","predicate","result","Map","set","toLowerCase","description","userStringProperties","userStringProperty","get","booleanProperties","booleanProperty","tristateProperties","tristateProperty","numericalProperties","numericalProperty","tokenProperties","tokenProperty","payloads","nodeById","nodeId","values","childId","childIds","next","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {Object} SerializedAXNode\n * @property {string} role\n *\n * @property {string=} name\n * @property {string|number=} value\n * @property {string=} description\n *\n * @property {string=} keyshortcuts\n * @property {string=} roledescription\n * @property {string=} valuetext\n *\n * @property {boolean=} disabled\n * @property {boolean=} expanded\n * @property {boolean=} focused\n * @property {boolean=} modal\n * @property {boolean=} multiline\n * @property {boolean=} multiselectable\n * @property {boolean=} readonly\n * @property {boolean=} required\n * @property {boolean=} selected\n *\n * @property {boolean|\"mixed\"=} checked\n * @property {boolean|\"mixed\"=} pressed\n *\n * @property {number=} level\n * @property {number=} valuemin\n * @property {number=} valuemax\n *\n * @property {string=} autocomplete\n * @property {string=} haspopup\n * @property {string=} invalid\n * @property {string=} orientation\n *\n * @property {Array<SerializedAXNode>=} children\n */\n\nclass Accessibility {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n  }\n\n  /**\n   * @param {{interestingOnly?: boolean, root?: ?Puppeteer.ElementHandle}=} options\n   * @return {!Promise<!SerializedAXNode>}\n   */\n  async snapshot(options = {}) {\n    const {\n      interestingOnly = true,\n      root = null,\n    } = options;\n    const {nodes} = await this._client.send('Accessibility.getFullAXTree');\n    let backendNodeId = null;\n    if (root) {\n      const {node} = await this._client.send('DOM.describeNode', {objectId: root._remoteObject.objectId});\n      backendNodeId = node.backendNodeId;\n    }\n    const defaultRoot = AXNode.createTree(nodes);\n    let needle = defaultRoot;\n    if (backendNodeId) {\n      needle = defaultRoot.find(node => node._payload.backendDOMNodeId === backendNodeId);\n      if (!needle)\n        return null;\n    }\n    if (!interestingOnly)\n      return serializeTree(needle)[0];\n\n    /** @type {!Set<!AXNode>} */\n    const interestingNodes = new Set();\n    collectInterestingNodes(interestingNodes, defaultRoot, false);\n    if (!interestingNodes.has(needle))\n      return null;\n    return serializeTree(needle, interestingNodes)[0];\n  }\n}\n\n/**\n * @param {!Set<!AXNode>} collection\n * @param {!AXNode} node\n * @param {boolean} insideControl\n */\nfunction collectInterestingNodes(collection, node, insideControl) {\n  if (node.isInteresting(insideControl))\n    collection.add(node);\n  if (node.isLeafNode())\n    return;\n  insideControl = insideControl || node.isControl();\n  for (const child of node._children)\n    collectInterestingNodes(collection, child, insideControl);\n}\n\n/**\n * @param {!AXNode} node\n * @param {!Set<!AXNode>=} whitelistedNodes\n * @return {!Array<!SerializedAXNode>}\n */\nfunction serializeTree(node, whitelistedNodes) {\n  /** @type {!Array<!SerializedAXNode>} */\n  const children = [];\n  for (const child of node._children)\n    children.push(...serializeTree(child, whitelistedNodes));\n\n  if (whitelistedNodes && !whitelistedNodes.has(node))\n    return children;\n\n  const serializedNode = node.serialize();\n  if (children.length)\n    serializedNode.children = children;\n  return [serializedNode];\n}\n\n\nclass AXNode {\n  /**\n   * @param {!Protocol.Accessibility.AXNode} payload\n   */\n  constructor(payload) {\n    this._payload = payload;\n\n    /** @type {!Array<!AXNode>} */\n    this._children = [];\n\n    this._richlyEditable = false;\n    this._editable = false;\n    this._focusable = false;\n    this._expanded = false;\n    this._hidden = false;\n    this._name = this._payload.name ? this._payload.name.value : '';\n    this._role = this._payload.role ? this._payload.role.value : 'Unknown';\n    this._cachedHasFocusableChild;\n\n    for (const property of this._payload.properties || []) {\n      if (property.name === 'editable') {\n        this._richlyEditable = property.value.value === 'richtext';\n        this._editable = true;\n      }\n      if (property.name === 'focusable')\n        this._focusable = property.value.value;\n      if (property.name === 'expanded')\n        this._expanded = property.value.value;\n      if (property.name === 'hidden')\n        this._hidden = property.value.value;\n    }\n  }\n\n  /**\n   * @return {boolean}\n   */\n  _isPlainTextField() {\n    if (this._richlyEditable)\n      return false;\n    if (this._editable)\n      return true;\n    return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';\n  }\n\n  /**\n   * @return {boolean}\n   */\n  _isTextOnlyObject() {\n    const role = this._role;\n    return (role === 'LineBreak' || role === 'text' ||\n            role === 'InlineTextBox');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  _hasFocusableChild() {\n    if (this._cachedHasFocusableChild === undefined) {\n      this._cachedHasFocusableChild = false;\n      for (const child of this._children) {\n        if (child._focusable || child._hasFocusableChild()) {\n          this._cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n    return this._cachedHasFocusableChild;\n  }\n\n  /**\n   * @param {function(AXNode):boolean} predicate\n   * @return {?AXNode}\n   */\n  find(predicate) {\n    if (predicate(this))\n      return this;\n    for (const child of this._children) {\n      const result = child.find(predicate);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isLeafNode() {\n    if (!this._children.length)\n      return true;\n\n    // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n    if (this._isPlainTextField() || this._isTextOnlyObject())\n      return true;\n\n    // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n    switch (this._role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n      default:\n        break;\n    }\n\n    // Here and below: Android heuristics\n    if (this._hasFocusableChild())\n      return false;\n    if (this._focusable && this._name)\n      return true;\n    if (this._role === 'heading' && this._name)\n      return true;\n    return false;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isControl() {\n    switch (this._role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * @param {boolean} insideControl\n   * @return {boolean}\n   */\n  isInteresting(insideControl) {\n    const role = this._role;\n    if (role === 'Ignored' || this._hidden)\n      return false;\n\n    if (this._focusable || this._richlyEditable)\n      return true;\n\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl())\n      return true;\n\n    // A non focusable child of a control is not interesting\n    if (insideControl)\n      return false;\n\n    return this.isLeafNode() && !!this._name;\n  }\n\n  /**\n   * @return {!SerializedAXNode}\n   */\n  serialize() {\n    /** @type {!Map<string, number|string|boolean>} */\n    const properties = new Map();\n    for (const property of this._payload.properties || [])\n      properties.set(property.name.toLowerCase(), property.value.value);\n    if (this._payload.name)\n      properties.set('name', this._payload.name.value);\n    if (this._payload.value)\n      properties.set('value', this._payload.value.value);\n    if (this._payload.description)\n      properties.set('description', this._payload.description.value);\n\n    /** @type {SerializedAXNode} */\n    const node = {\n      role: this._role\n    };\n\n    /** @type {!Array<keyof SerializedAXNode>} */\n    const userStringProperties = [\n      'name',\n      'value',\n      'description',\n      'keyshortcuts',\n      'roledescription',\n      'valuetext',\n    ];\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty))\n        continue;\n      node[userStringProperty] = properties.get(userStringProperty);\n    }\n\n    /** @type {!Array<keyof SerializedAXNode>} */\n    const booleanProperties = [\n      'disabled',\n      'expanded',\n      'focused',\n      'modal',\n      'multiline',\n      'multiselectable',\n      'readonly',\n      'required',\n      'selected',\n    ];\n    for (const booleanProperty of booleanProperties) {\n      // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,\n      // not whether focus is specifically on the root node.\n      if (booleanProperty === 'focused' && this._role === 'WebArea')\n        continue;\n      const value = properties.get(booleanProperty);\n      if (!value)\n        continue;\n      node[booleanProperty] = value;\n    }\n\n    /** @type {!Array<keyof SerializedAXNode>} */\n    const tristateProperties = [\n      'checked',\n      'pressed',\n    ];\n    for (const tristateProperty of tristateProperties) {\n      if (!properties.has(tristateProperty))\n        continue;\n      const value = properties.get(tristateProperty);\n      node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n    const numericalProperties = [\n      'level',\n      'valuemax',\n      'valuemin',\n    ];\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty))\n        continue;\n      node[numericalProperty] = properties.get(numericalProperty);\n    }\n    /** @type {!Array<keyof SerializedAXNode>} */\n    const tokenProperties = [\n      'autocomplete',\n      'haspopup',\n      'invalid',\n      'orientation',\n    ];\n    for (const tokenProperty of tokenProperties) {\n      const value = properties.get(tokenProperty);\n      if (!value || value === 'false')\n        continue;\n      node[tokenProperty] = value;\n    }\n    return node;\n  }\n\n  /**\n   * @param {!Array<!Protocol.Accessibility.AXNode>} payloads\n   * @return {!AXNode}\n   */\n  static createTree(payloads) {\n    /** @type {!Map<string, !AXNode>} */\n    const nodeById = new Map();\n    for (const payload of payloads)\n      nodeById.set(payload.nodeId, new AXNode(payload));\n    for (const node of nodeById.values()) {\n      for (const childId of node._payload.childIds || [])\n        node._children.push(nodeById.get(childId));\n    }\n    return nodeById.values().next().value;\n  }\n}\n\nmodule.exports = {Accessibility};\n"]},"metadata":{},"sourceType":"script"}
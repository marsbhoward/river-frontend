{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {\n  TimeoutError\n} = require('./Errors');\n\nconst debugError = require('debug')(`puppeteer:error`);\n\nconst fs = require('fs');\n\nclass Helper {\n  /**\n   * @param {Function|string} fun\n   * @param {!Array<*>} args\n   * @return {string}\n   */\n  static evaluationString(fun, ...args) {\n    if (Helper.isString(fun)) {\n      assert(args.length === 0, 'Cannot evaluate a string with arguments');\n      return (\n        /** @type {string} */\n        fun\n      );\n    }\n\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n    /**\n     * @param {*} arg\n     * @return {string}\n     */\n\n    function serializeArgument(arg) {\n      if (Object.is(arg, undefined)) return 'undefined';\n      return JSON.stringify(arg);\n    }\n  }\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   * @return {string}\n   */\n\n\n  static getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception) return exceptionDetails.exception.description || exceptionDetails.exception.value;\n    let message = exceptionDetails.text;\n\n    if (exceptionDetails.stackTrace) {\n      for (const callframe of exceptionDetails.stackTrace.callFrames) {\n        const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n        const functionName = callframe.functionName || '<anonymous>';\n        message += `\\n    at ${functionName} (${location})`;\n      }\n    }\n\n    return message;\n  }\n  /**\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {*}\n   */\n\n\n  static valueFromRemoteObject(remoteObject) {\n    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n\n    if (remoteObject.unserializableValue) {\n      if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined') return BigInt(remoteObject.unserializableValue.replace('n', ''));\n\n      switch (remoteObject.unserializableValue) {\n        case '-0':\n          return -0;\n\n        case 'NaN':\n          return NaN;\n\n        case 'Infinity':\n          return Infinity;\n\n        case '-Infinity':\n          return -Infinity;\n\n        default:\n          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n      }\n    }\n\n    return remoteObject.value;\n  }\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n\n\n  static async releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId) return;\n    await client.send('Runtime.releaseObject', {\n      objectId: remoteObject.objectId\n    }).catch(error => {\n      // Exceptions might happen in case of a page been navigated or closed.\n      // Swallow these since they are harmless and we don't leak anything in this case.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {!Object} classType\n   */\n\n\n  static installAsyncStackHooks(classType) {\n    for (const methodName of Reflect.ownKeys(classType.prototype)) {\n      const method = Reflect.get(classType.prototype, methodName);\n      if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function' || method.constructor.name !== 'AsyncFunction') continue;\n      Reflect.set(classType.prototype, methodName, function (...args) {\n        const syncStack = {};\n        Error.captureStackTrace(syncStack);\n        return method.call(this, ...args).catch(e => {\n          const stack = syncStack.stack.substring(syncStack.stack.indexOf('\\n') + 1);\n          const clientStack = stack.substring(stack.indexOf('\\n'));\n          if (e instanceof Error && e.stack && !e.stack.includes(clientStack)) e.stack += '\\n  -- ASYNC --\\n' + stack;\n          throw e;\n        });\n      });\n    }\n  }\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function(?):void} handler\n   * @return {{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?)}}\n   */\n\n\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return {\n      emitter,\n      eventName,\n      handler\n    };\n  }\n  /**\n   * @param {!Array<{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?):void}>} listeners\n   */\n\n\n  static removeEventListeners(listeners) {\n    for (const listener of listeners) listener.emitter.removeListener(listener.eventName, listener.handler);\n\n    listeners.length = 0;\n  }\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n\n\n  static isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n  }\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n\n\n  static isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n  }\n  /**\n   * @param {function} nodeFunction\n   * @return {function}\n   */\n\n\n  static promisify(nodeFunction) {\n    function promisified(...args) {\n      return new Promise((resolve, reject) => {\n        function callback(err, ...result) {\n          if (err) return reject(err);\n          if (result.length === 1) return resolve(result[0]);\n          return resolve(result);\n        }\n\n        nodeFunction.call(null, ...args, callback);\n      });\n    }\n\n    return promisified;\n  }\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function} predicate\n   * @param {number} timeout\n   * @param {!Promise<!Error>} abortPromise\n   * @return {!Promise}\n   */\n\n\n  static async waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    const listener = Helper.addEventListener(emitter, eventName, event => {\n      if (!predicate(event)) return;\n      resolveCallback(event);\n    });\n\n    if (timeout) {\n      eventTimeout = setTimeout(() => {\n        rejectCallback(new TimeoutError('Timeout exceeded while waiting for event'));\n      }, timeout);\n    }\n\n    function cleanup() {\n      Helper.removeEventListeners([listener]);\n      clearTimeout(eventTimeout);\n    }\n\n    const result = await Promise.race([promise, abortPromise]).then(r => {\n      cleanup();\n      return r;\n    }, e => {\n      cleanup();\n      throw e;\n    });\n    if (result instanceof Error) throw result;\n    return result;\n  }\n  /**\n   * @template T\n   * @param {!Promise<T>} promise\n   * @param {string} taskName\n   * @param {number} timeout\n   * @return {!Promise<T>}\n   */\n\n\n  static async waitWithTimeout(promise, taskName, timeout) {\n    let reject;\n    const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n    const timeoutPromise = new Promise((resolve, x) => reject = x);\n    let timeoutTimer = null;\n    if (timeout) timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n\n    try {\n      return await Promise.race([promise, timeoutPromise]);\n    } finally {\n      if (timeoutTimer) clearTimeout(timeoutTimer);\n    }\n  }\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {string} handle\n   * @param {?string} path\n   * @return {!Promise<!Buffer>}\n   */\n\n\n  static async readProtocolStream(client, handle, path) {\n    let eof = false;\n    let file;\n    if (path) file = await openAsync(path, 'w');\n    const bufs = [];\n\n    while (!eof) {\n      const response = await client.send('IO.read', {\n        handle\n      });\n      eof = response.eof;\n      const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);\n      bufs.push(buf);\n      if (path) await writeAsync(file, buf);\n    }\n\n    if (path) await closeAsync(file);\n    await client.send('IO.close', {\n      handle\n    });\n    let resultBuffer = null;\n\n    try {\n      resultBuffer = Buffer.concat(bufs);\n    } finally {\n      return resultBuffer;\n    }\n  }\n\n}\n\nconst openAsync = Helper.promisify(fs.open);\nconst writeAsync = Helper.promisify(fs.write);\nconst closeAsync = Helper.promisify(fs.close);\n/**\n * @param {*} value\n * @param {string=} message\n */\n\nfunction assert(value, message) {\n  if (!value) throw new Error(message);\n}\n\nmodule.exports = {\n  helper: Helper,\n  assert,\n  debugError\n};","map":{"version":3,"sources":["/Users/marshoward/Development/code/river/frontend/app/node_modules/puppeteer/lib/helper.js"],"names":["TimeoutError","require","debugError","fs","Helper","evaluationString","fun","args","isString","assert","length","map","serializeArgument","join","arg","Object","is","undefined","JSON","stringify","getExceptionMessage","exceptionDetails","exception","description","value","message","text","stackTrace","callframe","callFrames","location","url","lineNumber","columnNumber","functionName","valueFromRemoteObject","remoteObject","objectId","unserializableValue","type","BigInt","replace","NaN","Infinity","Error","releaseObject","client","send","catch","error","installAsyncStackHooks","classType","methodName","Reflect","ownKeys","prototype","method","get","startsWith","constructor","name","set","syncStack","captureStackTrace","call","e","stack","substring","indexOf","clientStack","includes","addEventListener","emitter","eventName","handler","on","removeEventListeners","listeners","listener","removeListener","obj","String","isNumber","Number","promisify","nodeFunction","promisified","Promise","resolve","reject","callback","err","result","waitForEvent","predicate","timeout","abortPromise","eventTimeout","resolveCallback","rejectCallback","promise","event","setTimeout","cleanup","clearTimeout","race","then","r","waitWithTimeout","taskName","timeoutError","timeoutPromise","x","timeoutTimer","readProtocolStream","handle","path","eof","file","openAsync","bufs","response","buf","Buffer","from","data","base64Encoded","push","writeAsync","closeAsync","resultBuffer","concat","open","write","close","module","exports","helper"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {TimeoutError} = require('./Errors');\nconst debugError = require('debug')(`puppeteer:error`);\nconst fs = require('fs');\n\nclass Helper {\n  /**\n   * @param {Function|string} fun\n   * @param {!Array<*>} args\n   * @return {string}\n   */\n  static evaluationString(fun, ...args) {\n    if (Helper.isString(fun)) {\n      assert(args.length === 0, 'Cannot evaluate a string with arguments');\n      return /** @type {string} */ (fun);\n    }\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n\n    /**\n     * @param {*} arg\n     * @return {string}\n     */\n    function serializeArgument(arg) {\n      if (Object.is(arg, undefined))\n        return 'undefined';\n      return JSON.stringify(arg);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   * @return {string}\n   */\n  static getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception)\n      return exceptionDetails.exception.description || exceptionDetails.exception.value;\n    let message = exceptionDetails.text;\n    if (exceptionDetails.stackTrace) {\n      for (const callframe of exceptionDetails.stackTrace.callFrames) {\n        const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n        const functionName = callframe.functionName || '<anonymous>';\n        message += `\\n    at ${functionName} (${location})`;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {*}\n   */\n  static valueFromRemoteObject(remoteObject) {\n    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n    if (remoteObject.unserializableValue) {\n      if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined')\n        return BigInt(remoteObject.unserializableValue.replace('n', ''));\n      switch (remoteObject.unserializableValue) {\n        case '-0':\n          return -0;\n        case 'NaN':\n          return NaN;\n        case 'Infinity':\n          return Infinity;\n        case '-Infinity':\n          return -Infinity;\n        default:\n          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n      }\n    }\n    return remoteObject.value;\n  }\n\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n  static async releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId)\n      return;\n    await client.send('Runtime.releaseObject', {objectId: remoteObject.objectId}).catch(error => {\n      // Exceptions might happen in case of a page been navigated or closed.\n      // Swallow these since they are harmless and we don't leak anything in this case.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!Object} classType\n   */\n  static installAsyncStackHooks(classType) {\n    for (const methodName of Reflect.ownKeys(classType.prototype)) {\n      const method = Reflect.get(classType.prototype, methodName);\n      if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function' || method.constructor.name !== 'AsyncFunction')\n        continue;\n      Reflect.set(classType.prototype, methodName, function(...args) {\n        const syncStack = {};\n        Error.captureStackTrace(syncStack);\n        return method.call(this, ...args).catch(e => {\n          const stack = syncStack.stack.substring(syncStack.stack.indexOf('\\n') + 1);\n          const clientStack = stack.substring(stack.indexOf('\\n'));\n          if (e instanceof Error && e.stack && !e.stack.includes(clientStack))\n            e.stack += '\\n  -- ASYNC --\\n' + stack;\n          throw e;\n        });\n      });\n    }\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function(?):void} handler\n   * @return {{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?)}}\n   */\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return { emitter, eventName, handler };\n  }\n\n  /**\n   * @param {!Array<{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?):void}>} listeners\n   */\n  static removeEventListeners(listeners) {\n    for (const listener of listeners)\n      listener.emitter.removeListener(listener.eventName, listener.handler);\n    listeners.length = 0;\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n  }\n\n  /**\n   * @param {function} nodeFunction\n   * @return {function}\n   */\n  static promisify(nodeFunction) {\n    function promisified(...args) {\n      return new Promise((resolve, reject) => {\n        function callback(err, ...result) {\n          if (err)\n            return reject(err);\n          if (result.length === 1)\n            return resolve(result[0]);\n          return resolve(result);\n        }\n        nodeFunction.call(null, ...args, callback);\n      });\n    }\n    return promisified;\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function} predicate\n   * @param {number} timeout\n   * @param {!Promise<!Error>} abortPromise\n   * @return {!Promise}\n   */\n  static async waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    const listener = Helper.addEventListener(emitter, eventName, event => {\n      if (!predicate(event))\n        return;\n      resolveCallback(event);\n    });\n    if (timeout) {\n      eventTimeout = setTimeout(() => {\n        rejectCallback(new TimeoutError('Timeout exceeded while waiting for event'));\n      }, timeout);\n    }\n    function cleanup() {\n      Helper.removeEventListeners([listener]);\n      clearTimeout(eventTimeout);\n    }\n    const result = await Promise.race([promise, abortPromise]).then(r => {\n      cleanup();\n      return r;\n    }, e => {\n      cleanup();\n      throw e;\n    });\n    if (result instanceof Error)\n      throw result;\n    return result;\n  }\n\n  /**\n   * @template T\n   * @param {!Promise<T>} promise\n   * @param {string} taskName\n   * @param {number} timeout\n   * @return {!Promise<T>}\n   */\n  static async waitWithTimeout(promise, taskName, timeout) {\n    let reject;\n    const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n    const timeoutPromise = new Promise((resolve, x) => reject = x);\n    let timeoutTimer = null;\n    if (timeout)\n      timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n    try {\n      return await Promise.race([promise, timeoutPromise]);\n    } finally {\n      if (timeoutTimer)\n        clearTimeout(timeoutTimer);\n    }\n  }\n\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {string} handle\n   * @param {?string} path\n   * @return {!Promise<!Buffer>}\n   */\n  static async readProtocolStream(client, handle, path) {\n    let eof = false;\n    let file;\n    if (path)\n      file = await openAsync(path, 'w');\n    const bufs = [];\n    while (!eof) {\n      const response = await client.send('IO.read', {handle});\n      eof = response.eof;\n      const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);\n      bufs.push(buf);\n      if (path)\n        await writeAsync(file, buf);\n    }\n    if (path)\n      await closeAsync(file);\n    await client.send('IO.close', {handle});\n    let resultBuffer = null;\n    try {\n      resultBuffer = Buffer.concat(bufs);\n    } finally {\n      return resultBuffer;\n    }\n  }\n}\n\nconst openAsync = Helper.promisify(fs.open);\nconst writeAsync = Helper.promisify(fs.write);\nconst closeAsync = Helper.promisify(fs.close);\n\n/**\n * @param {*} value\n * @param {string=} message\n */\nfunction assert(value, message) {\n  if (!value)\n    throw new Error(message);\n}\n\nmodule.exports = {\n  helper: Helper,\n  assert,\n  debugError\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n/* Repo is an abstract class\n *\n *\n */\n\n\nclass Repo {\n  initialize() {\n    return Promise.resolve();\n  }\n  /*\n      * - normalizedReq, Array\n      *   - sign, String\n      *   - options, Object, this is options for one request\n      * - options, Object, this is options for all requests\n      * - callback, Function\n      *\n      * Priority of two options : normalizedReq.options > options\n      */\n\n\n  exists(normalizedReq, options) {\n    const req = normalizedReq;\n    const slots = {};\n    const uniq = [];\n    const keysToInsert = {};\n    const rst = new Array(req.length);\n\n    for (let i = 0; i < req.length; i++) {\n      const reqOptions = Object.assign({}, options, req[i].options);\n      const key = this.transformKey(req[i].sign);\n\n      if (key in slots) {\n        rst[i] = true;\n      } else {\n        rst[i] = false;\n        slots[key] = i;\n        uniq.push(key);\n        keysToInsert[key] = null;\n\n        if (reqOptions.rupdate === false) {\n          delete keysToInsert[key];\n        }\n      }\n    }\n\n    return this.getByKeys(uniq).then(result => {\n      const ifTruthy = key => key === '1' || key === 1 || key === 'true' || key === true;\n\n      for (let j = 0; j < uniq.length; j++) {\n        if (ifTruthy(result[j])) {\n          rst[slots[uniq[j]]] = true;\n          delete keysToInsert[uniq[j]];\n        } else {\n          rst[slots[uniq[j]]] = false;\n        }\n      }\n\n      return this.setByKeys(Object.keys(keysToInsert));\n    }).then(() => {\n      return rst;\n    });\n  }\n  /*\n      * \n      * @return Array, transformed keys\n      *\n      */\n\n\n  transformKey(key) {\n    const hash = str => {\n      const hashFn = crypto.createHash('md5');\n      hashFn.update(str);\n      return hashFn.digest('hex');\n    };\n\n    return hash(key);\n  }\n\n  dispose() {\n    throw new Error('`dispose` not implemented');\n  }\n\n}\n\nmodule.exports = Repo;","map":{"version":3,"sources":["/Users/marshoward/Development/code/river/frontend/app/node_modules/seenreq/repo.js"],"names":["crypto","require","Repo","initialize","Promise","resolve","exists","normalizedReq","options","req","slots","uniq","keysToInsert","rst","Array","length","i","reqOptions","Object","assign","key","transformKey","sign","push","rupdate","getByKeys","then","result","ifTruthy","j","setByKeys","keys","hash","str","hashFn","createHash","update","digest","dispose","Error","module","exports"],"mappings":"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","sourcesContent":["\n'use strict';\n\nconst crypto = require('crypto');\n\n/* Repo is an abstract class\n *\n *\n */\nclass Repo{\n\tinitialize(){\n\t\treturn Promise.resolve();\n\t}\n\n\t/*\n     * - normalizedReq, Array\n     *   - sign, String\n     *   - options, Object, this is options for one request\n     * - options, Object, this is options for all requests\n     * - callback, Function\n     *\n     * Priority of two options : normalizedReq.options > options\n     */\n\texists(normalizedReq, options){\n\t\tconst req = normalizedReq;\n\t\tconst slots = {};\n\t\tconst uniq = [];\n\t\tconst keysToInsert = {};\n\t\tconst rst = new Array(req.length);\n\n\t\tfor (let i = 0; i < req.length; i++) {\n\t\t\tconst reqOptions = Object.assign({},options,req[i].options);\n\t\t\tconst key = this.transformKey(req[i].sign);\n\t\t\tif (key in slots) {\n\t\t\t\trst[i] = true;\n\t\t\t} else {\n\t\t\t\trst[i] = false;\n\t\t\t\tslots[key] = i;\n\t\t\t\tuniq.push(key);\n\t\t\t\tkeysToInsert[key] = null;\n\t\t\t\t\n\t\t\t\tif (reqOptions.rupdate === false) {\n\t\t\t\t\tdelete keysToInsert[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this.getByKeys(uniq).then( (result) => {\n\t\t\tconst ifTruthy = (key) => key==='1' || key===1 || key==='true' || key===true ;\n\t\t\t\n\t\t\tfor (let j = 0; j < uniq.length; j++) {\n\t\t\t\tif (ifTruthy(result[j])) {\n\t\t\t\t\trst[slots[uniq[j]]] = true;\n\t\t\t\t\tdelete keysToInsert[uniq[j]];\n\t\t\t\t} else {\n\t\t\t\t\trst[slots[uniq[j]]] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.setByKeys(Object.keys(keysToInsert));\n\t\t}).then( () => {\n\t\t\treturn rst;\n\t\t});\n\t}\n\n\t/*\n     * \n     * @return Array, transformed keys\n     *\n     */\n\ttransformKey(key){\n\t\tconst hash = (str) => {\n\t\t\tconst hashFn = crypto.createHash('md5');\n\t\t\thashFn.update(str);\n\t\t\treturn hashFn.digest('hex');\n\t\t};\n\t\t\n\t\treturn hash(key);\n\t}\n\n\tdispose(){\n\t\tthrow new Error('`dispose` not implemented');\n\t}\n}\n\nmodule.exports = Repo;\n"]},"metadata":{},"sourceType":"script"}